# -*- coding: utf-8 -*-
"""AI AUTOGRADER PROJECT WORKING.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13eS3pJtmh19IDNM1QUnkqBw3hBxPvSQ7
"""

!pip install openai --quiet
!pip install tiktoken --quiet

!pip install --upgrade openai

import openai
import json

# Initialize OpenAI client with API key
client = openai.Client(api_key="")

def ai_autograde_gpt4(question_type, question_text, student_answer, grading_instructions):
    response = client.chat.completions.create(
        model="gpt-4",
        messages=[
            {"role": "system", "content": f"You are an expert {question_type} grader."},
            {"role": "user", "content": f"""
                Question Type: {question_type}
                Question Text: {question_text}

                Student Submission:
                {student_answer}

                Grading Instructions:
                {grading_instructions}

                Return JSON output in this format:
                {{
                  "score": <integer from 0 to 10>,
                  "feedback": "Provide 2-3 lines of feedback."
                }}
            """}
        ],
        temperature=0.0
    )

    # Parse the response
    try:
        result = json.loads(response.choices[0].message.content)
    except json.JSONDecodeError:
        result = {
            "score": 0,
            "feedback": "Unable to parse response. Please review manually."
        }
    return result


# Test the API with Sample Data
def main():
    question_text = """
    CS-531: Fundamentals of Systems Programming
    Fall 2024 - Instructor: Hal Greenwald
    Homework #2 - IPv4 Address Management Program

    Design and implement a C program to manage IPv4 addresses and aliases using a singly linked list.
    Your program will read from a file CS531_Inet.txt containing address/alias pairs and allow operations through a menu-driven interface.

    Requirements:
    1. Create a structure address_t with:
      - int octet[4] – Four integers representing IPv4 address.
      - char alias[11] – Alias (up to 10 characters, case insensitive).
      - struct address_t *next – Pointer for linked list.
    2. Implement a singly linked list to store address/alias pairs.
    3. Provide a menu for users to:
      1) Add address
      2) Look up address
      3) Update address
      4) Delete address
      5) Display list
      6) Display aliases for location
      7) Save to file
      8) Quit
    4. Validate IPv4 addresses and alias lengths (≤ 10 characters).
    5. Handle duplicate address/alias errors.

    Sample CS531_Inet.txt:
    111.22.3.44 platte
    131.250.95.21 jet
    172.66.7.88 wabash
    111.22.5.66 green
    131.250.47.63 baker
    """
    student_answer = """
    #include<stdio.h>
    #include<string.h>
    #include<stdlib.h>

    // Structure to store each address entry
    struct address_t
    {
        int myOct[4];        // Array to hold the IP address (four octets)
        char alias[11];      // Array to hold the alias
        struct address_t *next; // Pointer to the next address in the linked list
    };

    // Function declarations (now the compiler knows about address_t)
    void readAddress(const char *filename);
    void displayList();
    void addAddress();
    void lookUpAddress();
    void updateAddress();
    void deleteAddress();
    void displayAliasesForLocation();
    void saveToFile();
    void printAddress(struct address_t *address); // Declaration for printAddress

    // Global pointer to the head of the linked list
    struct address_t *head = NULL;

    int main(){
        readAddress("CS531_Inet.txt");  // Load addresses from a file on startup
        int choice;  // User's menu choice

        do {
            // Display menu options
            printf("\nMenu:\n");
            printf("1. Add Address\n");
            printf("2. Lookup Address by Alias\n");
            printf("3. Update Address by Alias\n");
            printf("4. Delete Address by Alias\n");
            printf("5. Display All Addresses\n");
            printf("6. Display Aliases by Location\n");
            printf("7. Save Addresses to File\n");
            printf("0. Exit\n");
            printf("Enter your choice: ");
            scanf("%d", &choice);
            getchar(); // Consume the newline left by scanf

            // Handle the user's menu choice
            switch (choice) {
                case 1: addAddress(); break;
                case 2: lookUpAddress(); break;
                case 3: updateAddress(); break;
                case 4: deleteAddress(); break;
                case 5: displayList(); break;
                case 6: displayAliasesForLocation(); break;
                case 7: saveToFile(); break;
                case 0: printf("Exiting the program. Goodbye!\n"); break;
                default: printf("Invalid choice. Please enter a number from 0 to 7.\n");
            }
        } while (choice != 0);

        return 0;
    }

    // Helper function to print address and alias
    void printAddress(struct address_t *address) {
        printf("%d.%d.%d.%d -> %s\n", address->myOct[0], address->myOct[1], address->myOct[2], address->myOct[3], address->alias);
    }

    // Function to add a new address
    void addAddress() {
        struct address_t *newNode = malloc(sizeof(struct address_t));  // Allocate memory for a new node
        char addressString[20];
        int octets[4];

        // Input alias and validate
        printf("Enter alias (max 10 characters): ");
        fgets(newNode->alias, sizeof(newNode->alias), stdin);
        newNode->alias[strcspn(newNode->alias, "\n")] = '\0'; // Remove newline

        // Check if alias already exists
        struct address_t *current = head;
        while (current) {
            if (strcmp(current->alias, newNode->alias) == 0) {
                printf("Error: Alias already exists. Please choose a different alias.\n");
                free(newNode);
                return;
            }
            current = current->next;
        }

        // Input and validate IP address
        while (1) {
            printf("Enter IPv4 address (format: xxx.xxx.xxx.xxx): ");
            fgets(addressString, sizeof(addressString), stdin);
            if (sscanf(addressString, "%d.%d.%d.%d", &octets[0], &octets[1], &octets[2], &octets[3]) == 4 &&
                octets[0] >= 0 && octets[0] <= 255 &&
                octets[1] >= 0 && octets[1] <= 255 &&
                octets[2] >= 0 && octets[2] <= 255 &&
                octets[3] >= 0 && octets[3] <= 255) {
                break; // IP address is valid
            } else {
                printf("Error: Invalid IP address. Please try again.\n");
            }
        }

        // Assign the IP address to the new node
        for (int i = 0; i < 4; i++) {
            newNode->myOct[i] = octets[i];
        }

        // Add the new node to the head of the list
        newNode->next = head;
        head = newNode;
        printf("New address added successfully.\n");
    }

    // Function to read addresses from a file and populate the linked list
    void readAddress(const char *filename) {
        FILE *file = fopen(filename, "r");
        if (!file) {
            printf("Error: Could not open file '%s'.\n", filename);
            return;
        }

        char line[50];  // Buffer to store each line of the file
        while (fgets(line, sizeof(line), file)) {
            struct address_t *newNode = malloc(sizeof(struct address_t));  // Allocate memory for a new node
            int items = sscanf(line, "%d.%d.%d.%d %10s", &newNode->myOct[0], &newNode->myOct[1], &newNode->myOct[2], &newNode->myOct[3], newNode->alias);
            if (items == 5) { // Check if all parts of the line were read
                newNode->next = head;
                head = newNode; // Add the new node to the head of the linked list

                // Debug message for confirmation
                printf("Loaded: ");
                printAddress(newNode);  // Use the helper function to print the newly loaded address
            } else {
                printf("Error: Could not parse line: %s", line);
                free(newNode);  // Free memory if line parsing fails
            }
        }
        fclose(file);
    }

    // Function to display all addresses and aliases
    void displayList() {
        if (!head) {
            printf("No addresses to display. The list is empty.\n");
            return;
        }

        struct address_t *current = head;
        int count = 0;  // Track the number of entries

        printf("Stored Addresses and Aliases:\n");
        while (current) {
            printAddress(current);  // Use the helper function to print each address
            current = current->next;
            count++;
        }
        printf("Total number of entries: %d\n", count);
    }




    // Function to look up an address by its alias
    void lookUpAddress() {
        char alias[11];
        printf("Enter alias to search: ");
        fgets(alias, sizeof(alias), stdin);
        alias[strcspn(alias, "\n")] = '\0'; // Remove newline

        struct address_t *current = head;
        while (current) {
            if (strcmp(current->alias, alias) == 0) {
                printf("Found: ");
                printAddress(current);  // Use the helper function to print the found address
                return;
            }
            current = current->next;
        }
        printf("Error: Alias '%s' not found.\n", alias);
    }

    // Function to update an address by its alias
    void updateAddress() {
        char alias[11];
        printf("Enter alias to update: ");
        fgets(alias, sizeof(alias), stdin);
        alias[strcspn(alias, "\n")] = '\0'; // Remove newline

        struct address_t *current = head;
        while (current) {
            if (strcmp(current->alias, alias) == 0) {
                printf("Current address: ");
                printAddress(current);  // Use the helper function to print the current address

                int newOctets[4];

                // Prompt user for the new IP address
                for (int i = 0; i < 4; i++) {
                    while (1) {
                        printf("Enter new value for octet %d (0-255): ", i + 1);
                        scanf("%d", &newOctets[i]);
                        getchar(); // Consume newline

                        if (newOctets[i] < 0 || newOctets[i] > 255) {
                            printf("Error: %d is an invalid value. Please try again.\n", newOctets[i]);
                        } else {
                            break; // Valid input
                        }
                    }
                }

                // Update the address
                for (int i = 0; i < 4; i++) {
                    current->myOct[i] = newOctets[i];
                }
                printf("Address updated successfully to ");
                printAddress(current);  // Use the helper function to print the updated address
                return;
            }
            current = current->next;
        }
        printf("Error: Alias '%s' not found.\n", alias);
    }

    // Function to delete an address by its alias
    void deleteAddress() {
        char alias[11];
        printf("Enter alias to delete: ");
        fgets(alias, sizeof(alias), stdin);
        alias[strcspn(alias, "\n")] = '\0'; // Remove newline

        struct address_t *current = head;
        struct address_t *prev = NULL;

        while (current) {
            if (strcmp(current->alias, alias) == 0) {
                printf("Found: ");
                printAddress(current);  // Use the helper function to print the found address

                // Confirm deletion
                char confirm;
                printf("Are you sure you want to delete this address? (y/n): ");
                scanf("%c", &confirm);
                getchar(); // Consume newline

                if (confirm == 'y') {
                    if (prev) {
                        prev->next = current->next;
                    } else {
                        head = current->next;
                    }
                    free(current);
                    printf("Address deleted successfully.\n");
                    return;
                } else {
                    printf("Deletion canceled.\n");
                    return;
                }
            }
            prev = current;
            current = current->next;
        }
        printf("Error: Alias '%s' not found.\n", alias);
    }

    // Function to display aliases for a given location (based on first two octets)


    // Function to save the current addresses and aliases to a file
    void saveToFile() {
        char fileName[100];

        // Prompt user for the file name
        printf("Enter the file name to save to: ");
        fgets(fileName, sizeof(fileName), stdin);
        fileName[strcspn(fileName, "\n")] = '\0';  // Remove newline character

        // Open file for writing
        FILE *file = fopen(fileName, "w");
        if (!file) {
            printf("Error: Could not open file '%s' for writing.\n", fileName);
            return;
        }

        // Write each address and alias to the file
        struct address_t *current = head;
        while (current) {
            fprintf(file, "%d.%d.%d.%d %s\n", current->myOct[0], current->myOct[1], current->myOct[2], current->myOct[3], current->alias);
            current = current->next;
        }

        fclose(file);
        printf("Addresses saved successfully to '%s'.\n", fileName);
    }
    """
    grading_instructions = """
    Total Points: 10

    1. Code must have proper documentation, indentation, and comments. (1 point)
    2. Implement a singly linked list to manage address_t structures. (1 point)
    3. Implement the following menu functions (1 point each):
        - Add address (valid IPv4 parsing, alias <= 10 characters)
        - Look up address
        - Update address
        - Delete address
        - Display list
        - Display aliases for location
        - Save to file
        - Quit program cleanly
    4. Handle duplicate addresses and aliases with error messages.
    5. Use no 'goto' statements, follow structured programming.

    Ensure all functions are implemented separately and main() is at the top.
    """

    result = ai_autograde_gpt4("Code", question_text, student_answer, grading_instructions)
    print("Grading Result:", json.dumps(result, indent=2))

# Run the grading script
if __name__ == "__main__":
    main()